section .text

global _strncpy

; согласно соглашению о вызове elf64:
; 1-й целочисленный параметр (dst) - в rdi
; 2-й целочисленный параметр (src) - в rsi
; 3-й целочисленный параметр (n) - в rdx
; возвращаемое значение - в rax

_strncpy:
    ; проверки src и dst на nullptr не нужны, так как библиотечный strncpy не компилируется с nullptr в качестве параметра
    mov rbx, rdi    ; сохраняем dst в неиспользуемый регистр, чтобы в конце вернуть его из функции
    mov rcx, rdx    ; кладём n в rcx (счётчик повторений для MOVSB с префиксом повторения)
    
    ; следующий код (до метки copy) нужен для того, чтобы выявить случай перекрытия src и dst, причём src идёт раньше dst ; в таком случае надо копировать символы из конца в начало, чтобы "хвост" src не переписывался
    cmp rdi, rsi
    jbe copy        ; если dst <= src, то переходим к копированию

    mov rax, rdi
    sub rax, rsi
    cmp rax, rcx
    ja copy         ; если dst - src > len, то переходим к копированию
    
    ; сюда мы доходим только если dst > src и dst - src < len ; выполняем копирование в обратном порядке: из конца в начало
    add rdi, rcx
    dec rdi
    add rsi, rcx
    dec rsi         ; поставили rsi и rdi в концы строк, на которые они указывали
    std             ; установка флага направления DF, контролирующего поведение команд обработки строк (если установлен в 1, то строки обрабатываются в сторону уменьшения адресов, если сброшен в 0, то наоборот)

copy:
    rep movsb       ; запускаем цикл копирования строки
    cld             ; сброс флага направления DF
    mov rax, rbx    ; кладём в rax возвращаемое значение (указатель dst), который мы в самом начале сохранили в rbx
ret
