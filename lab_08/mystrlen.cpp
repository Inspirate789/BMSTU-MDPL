#include "mystrlen.h"

size_t mystrlen(const char *str)            // обёртка над ассемблерной вставкой
{
    size_t len = 0;

    __asm__(".intel_syntax noprefix\n\t"    // указываем интеловский синтаксис вставки, чтобы не писать в нативном стиле под gcc (с обратым порядком операндов, кучей "%" и т.д.)
            "mov rcx, -1\n\t"               // кладём в rcx (счётчик повторений для SCASB с префиксом повторения) самое большое число
            "mov rdi, %1\n\t"               // кладём в rdi (адрес строки, которую будет обрабатывать scasb) первый параметр ассемблерной вставки (str)
            "mov al, 0\n\t"                 // кладём в al символ ('\0'), с которым будет сравниваться каждый символ строки
            "repne scasb\n\t"               // запускаем цикл обработки строки // он закончится тогда, когда rcx уменьшится до 0 (практически невозможно) или когда мы встретим '\0'
            "neg rcx\n\t"
            "sub rcx, 2\n\t"                // получили в rcx искомую длину строки без учёта '\0'
            "mov %0, rcx\n\t"               // кладём найденную длину строки в нулевой по счёту параметр ассемблерной вставки (len)
            : "=r" (len)                    // выходной параметр ассемблерной вставки
            : "r" (str)                     // входной параметр ассемблерной вставки
            : "rcx", "rdi", "al"            // список разрушаемых регистров (подчищаем за собой)
            );                              // у каждой команды пишем "\n\t", чтобы эти строки не слепились друг с другом, потому что GCC никак не интерпретирует содержимое ассемблерной вставки, воспринимая её как макроподстановку времени компиляции

    return len;
}
